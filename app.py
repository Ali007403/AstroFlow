# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mgiCPWeh9yxe09QNeIY_QDEtRJBJHcgX
"""

import streamlit as st
import numpy as np
import pandas as pd
import tempfile
import os
import io
import matplotlib.pyplot as plt
from astroflow import core
import plotly.graph_objects as go

st.set_page_config(page_title="AstroFlow", layout="wide", initial_sidebar_state="expanded")

# Helper functions
def make_key(*parts):
    return "_".join(str(p) for p in parts if p is not None).replace(" ", "_").replace(".", "_")[:200]

WL_COLS = ['WAVELENGTH', 'WAVE', 'LAMBDA', 'WLEN']
FLUX_COLS = ['FLUX', 'FLUX_DENSITY', 'SPECTRUM', 'INTENSITY']
DEFAULT_BANDS = {"Hâ‚‚O": (1.35, 1.45), "CHâ‚„": (1.60, 1.72), "COâ‚‚": (2.65, 2.75), "DMS": (3.75, 3.85), "CO": (4.65, 4.75)}

def try_extract_spectrum(hdu):
    if not hasattr(hdu.data, 'names'):
        arr = np.array(hdu.data)
        if arr.ndim == 1:
            wl = np.arange(arr.size)
            fl = arr.astype(float)
            mask = np.isfinite(fl)
            return wl[mask], fl[mask]
        elif arr.ndim == 2:
            fl = np.nanmean(arr, axis=0)
            wl = np.arange(fl.size)
            mask = np.isfinite(fl)
            return wl[mask], fl[mask]
        return None, None
    names = hdu.data.names
    wl_col = next((c for c in WL_COLS if c in names), None)
    fl_col = next((c for c in FLUX_COLS if c in names), None)
    if wl_col and fl_col:
        wl = np.array(hdu.data[wl_col]).astype(float).flatten()
        fl = np.array(hdu.data[fl_col]).astype(float).flatten()
        mask = np.isfinite(wl) & np.isfinite(fl)
        return wl[mask], fl[mask]
    nums = [n for n in names if np.issubdtype(hdu.data[n].dtype, np.number)]
    if len(nums) >= 2:
        wl = np.array(hdu.data[nums[0]]).astype(float).flatten()
        fl = np.array(hdu.data[nums[1]]).astype(float).flatten()
        mask = np.isfinite(wl) & np.isfinite(fl)
        return wl[mask], fl[mask]
    return None, None

def smooth_flux(flux, window, polyorder):
    if window % 2 == 0:
        window += 1
    if len(flux) >= window >= 3:
        try:
            return core.savgol_filter(flux, window, polyorder)
        except:
            return flux
    return flux

def plotly_spectrum(wl, fl, fl_smooth=None, title="Spectrum", bands=None, show_bands=True):
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=wl, y=fl, mode='lines', name='Raw', line=dict(color='rgba(0,150,200,0.7)')))
    if fl_smooth is not None:
        fig.add_trace(go.Scatter(x=wl, y=fl_smooth, mode='lines', name='Smoothed', line=dict(color='black', width=2)))
    if show_bands and bands:
        colors = ['skyblue', 'violet', 'lightgreen', 'gold', 'lightcoral']
        for i, (mol, (a, b)) in enumerate(bands.items()):
            fig.add_vrect(x0=a, x1=b, fillcolor=colors[i % len(colors)], opacity=0.25, layer="below", line_width=0, annotation_text=mol, annotation_position="top left")
    fig.update_layout(title=title, xaxis_title="Wavelength (Âµm)", yaxis_title="Flux", template="plotly_white", height=420)
    return fig

# Sidebar controls
st.sidebar.header("AstroFlow Controls")
smoothing_enabled = st.sidebar.checkbox("Enable smoothing", value=True)
smoothing_window = st.sidebar.slider("Smoothing window (odd)", 5, 501, 51, step=2)
polyorder = st.sidebar.slider("Polyorder", 1, 5, 3)
show_bands = st.sidebar.checkbox("Show molecular bands", value=True)
show_snr = st.sidebar.checkbox("Show SNR", value=True)
enable_downloads = st.sidebar.checkbox("Enable downloads", value=True)

# Main UI
st.title("ðŸ”­ AstroFlow")
st.markdown("Upload FITS files to analyze spectra, biosignatures, and SNR.")

# File upload
uploaded = st.file_uploader("Upload FITS files", type=["fits"], accept_multiple_files=True)
if not uploaded:
    st.info("Upload FITS files to begin.")
    st.stop()

# Save files to temp directory
work_dir = tempfile.mkdtemp(prefix="astroflow_")
file_paths = []
for up in uploaded:
    dst = os.path.join(work_dir, up.name)
    with open(dst, "wb") as f:
        f.write(up.read())
    file_paths.append(dst)
st.success(f"Saved {len(file_paths)} files.")

# Run core and capture outputs
def run_core_capture(paths):
    result = {"prints": "", "figs": [], "files": [], "returns": None}
    before_files = set(os.listdir(work_dir))
    pre_figs = set(plt.get_fignums())
    captured_figs = []
    orig_show = plt.show
    def fake_show(*a, **kw):
        try:
            fig = plt.gcf()
            captured_figs.append(fig)
            plt.close(fig)
        except:
            pass
    plt.show = fake_show
    stdout_buf = io.StringIO()
    
    try:
        with contextlib.redirect_stdout(stdout_buf):
            result["returns"] = core.analyze_all_fits(paths)
    except Exception as e:
        print(f"Error in core.analyze_all_fits: {e}")
    finally:
        plt.show = orig_show
    
    result["prints"] = stdout_buf.getvalue()
    post_figs = set(plt.get_fignums())
    result["figs"] = captured_figs + [plt.figure(n) for n in post_figs - pre_figs]
    result["files"] = [os.path.join(work_dir, f) for f in set(os.listdir(work_dir)) - before_files]
    return result

# Run core
if st.button("Run Analysis on All Files"):
    with st.spinner("Running analysis..."):
        res = run_core_capture(file_paths)
    
    # Display prints
    if res["prints"].strip():
        st.subheader("Logs")
        st.code(res["prints"])
    
    # Display figures
    if res["figs"]:
        st.subheader("Plots")
        for i, fig in enumerate(res["figs"]):
            try:
                st.pyplot(fig, key=make_key("fig", i))
            except:
                buf = io.BytesIO()
                fig.savefig(buf, format='png', bbox_inches='tight')
                buf.seek(0)
                st.image(buf, caption=f"Figure {i}", use_column_width=True, key=make_key("fig_img", i))
    
    # Display returned data
    if res["returns"]:
        st.subheader("Returned Data")
        if isinstance(res["returns"], (list, tuple)) and len(res["returns"]) >= 3:
            smoothed, ref_wl, valid_mask, *extra = res["returns"]
            # Spectrum plot
            fl_smooth = smooth_flux(smoothed, smoothing_window, polyorder) if smoothing_enabled else None
            fig = plotly_spectrum(ref_wl[valid_mask], smoothed[valid_mask], fl_smooth[valid_mask] if fl_smooth is not None else None,
                                 title="Stacked Spectrum", bands=DEFAULT_BANDS, show_bands=show_bands)
            st.plotly_chart(fig, use_container_width=True, key=make_key("spectrum_plot"))
            
            # DataFrame for download
            if enable_downloads:
                df = pd.DataFrame({"Wavelength": ref_wl[valid_mask], "Flux": smoothed[valid_mask]})
                if fl_smooth is not None:
                    df["Smoothed_Flux"] = fl_smooth[valid_mask]
                csv = df.to_csv(index=False).encode('utf-8')
                st.download_button("Download Spectrum CSV", csv, file_name="spectrum.csv", key=make_key("spectrum_csv"))
            
            # Biosignatures or SNR
            if extra:
                if len(extra) >= 2:  # Biosignatures
                    combined, bio_curves = extra[:2]
                    st.subheader("Biosignatures")
                    fig = plotly_spectrum(ref_wl[valid_mask], smoothed[valid_mask], title="Spectrum vs Biosignatures", bands=DEFAULT_BANDS, show_bands=show_bands)
                    fig.add_trace(go.Scatter(x=ref_wl[valid_mask], y=combined[valid_mask], mode='lines', name='Biosignatures', line=dict(dash='dash', color='tomato')))
                    for mol, curve in bio_curves.items():
                        fig.add_trace(go.Scatter(x=ref_wl[valid_mask], y=1 + curve[valid_mask], mode='lines', name=mol))
                    st.plotly_chart(fig, use_container_width=True, key=make_key("bio_plot"))
                    
                    if enable_downloads:
                        bio_df = pd.DataFrame({"Wavelength": ref_wl[valid_mask], "Combined_Biosignatures": combined[valid_mask]})
                        for mol, curve in bio_curves.items():
                            bio_df[mol] = 1 + curve[valid_mask]
                        csv = bio_df.to_csv(index=False).encode('utf-8')
                        st.download_button("Download Biosignatures CSV", csv, file_name="biosignatures.csv", key=make_key("bio_csv"))
                
                if show_snr and len(extra) >= 1 and isinstance(extra[-1], dict):  # SNR
                    st.subheader("SNR Results")
                    snr_results = extra[-1]
                    snr_df = pd.DataFrame(list(snr_results.items()), columns=["Molecule", "SNR (Ïƒ)"])
                    st.dataframe(snr_df)
                    if enable_downloads:
                        csv = snr_df.to_csv(index=False).encode('utf-8')
                        st.download_button("Download SNR CSV", csv, file_name="snr.csv", key=make_key("snr_csv"))
    
    # Display generated files
    if res["files"]:
        st.subheader("Generated Files")
        for f in res["files"]:
            fname = os.path.basename(f)
            if fname.lower().endswith(".csv"):
                try:
                    df = pd.read_csv(f)
                    st.dataframe(df.head(200), key=make_key("csv", fname))
                    if enable_downloads:
                        st.download_button(f"Download {fname}", open(f, "rb").read(), file_name=fname, key=make_key("dl", fname))
                except:
                    st.write(f"Failed to read {fname}")
            elif fname.lower().endswith((".png", ".jpg", ".jpeg")):
                st.image(f, caption=fname, use_column_width=True, key=make_key("img", fname))
                if enable_downloads:
                    st.download_button(f"Download {fname}", open(f, "rb").read(), file_name=fname, key=make_key("dl", fname))
            else:
                if enable_downloads:
                    st.download_button(f"Download {fname}", open(f, "rb").read(), file_name=fname, key=make_key("dl", fname))

# Per-file inspection
st.header("Per-File Inspection")
for idx, p in enumerate(file_paths):
    fname = os.path.basename(p)
    st.subheader(fname)
    if st.checkbox("Inspect HDUs", key=make_key("inspect", fname, idx)):
        try:
            with fits.open(p, memmap=False) as hdul:
                for h_i, hdu in enumerate(hdul):
                    st.markdown(f"**HDU {h_i}** â€” {hdu.__class__.__name__}")
                    st.write("Header:", {k: hdu.header[k] for k in list(hdu.header.keys())[:20]})
                    if hasattr(hdu.data, 'names'):
                        df = pd.DataFrame(hdu.data)
                        st.dataframe(df.head(200), key=make_key("table", fname, h_i))
                        if enable_downloads:
                            csv = df.to_csv(index=False).encode('utf-8')
                            st.download_button(f"Download HDU {h_i} Table", csv, file_name=f"{fname}_hdu{h_i}.csv", key=make_key("dl", fname, h_i, "table"))
                    if getattr(hdu.data, "ndim", 0) == 2:
                        fig, ax = plt.subplots(figsize=(6, 3))
                        ax.imshow(hdu.data, origin='lower', cmap='gray', aspect='auto')
                        ax.set_title(f"{fname} HDU {h_i} Image")
                        st.pyplot(fig, key=make_key("img", fname, h_i))
                        if enable_downloads:
                            buf = io.BytesIO()
                            fig.savefig(buf, format='png', bbox_inches='tight')
                            buf.seek(0)
                            st.download_button(f"Download HDU {h_i} Image", buf, file_name=f"{fname}_hdu{h_i}.png", key=make_key("dl", fname, h_i, "img"))
                    wl, fl = try_extract_spectrum(hdu)
                    if wl is not None:
                        st.write(f"Spectrum: {len(wl)} points, range {wl.min():.5g}â€“{wl.max():.5g}")
                        fl_smooth = smooth_flux(fl.copy(), smoothing_window, polyorder) if smoothing_enabled else None
                        fig = plotly_spectrum(wl, fl, fl_smooth, title=f"{fname} HDU {h_i}", bands=DEFAULT_BANDS, show_bands=show_bands)
                        st.plotly_chart(fig, use_container_width=True, key=make_key("plot", fname, h_i))
                        if enable_downloads:
                            df = pd.DataFrame({"Wavelength": wl, "Flux": fl})
                            if fl_smooth is not None:
                                df["Smoothed_Flux"] = fl_smooth
                            csv = df.to_csv(index=False).encode('utf-8')
                            st.download_button(f"Download HDU {h_i} Spectrum", csv, file_name=f"{fname}_hdu{h_i}_spectrum.csv", key=make_key("dl", fname, h_i, "spec"))
        except Exception as e:
            st.error(f"Failed to inspect {fname}: {e}")
