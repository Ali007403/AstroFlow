# -*- coding: utf-8 -*-
"""fields.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mgiCPWeh9yxe09QNeIY_QDEtRJBJHcgX
"""

# FitsFlow/fields.py
"""
Cross-field column / unit detection utilities.

Provides:
- COLUMN_ALIASES: common aliases for axis types
- normalize_colname: small normalizer to compare names robustly
- map_columns(df): map dataframe columns to canonical roles
- detect_data_type(mapping): classify the table (spectrum, map, generic)
"""

import re
from typing import Dict, List

COLUMN_ALIASES = {
    "wavelength": ["wavelength", "wave", "wl", "lambda", "lmbda", "wlen", "wavelength_um", "wavelength_micron", "nm", "ang"],
    "flux": ["flux", "intensity", "flux_density", "spectrum", "signal", "counts", "y", "value"],
    "x": ["x", "col", "pixel", "index"],
    "y": ["y", "row", "pixel", "index"],
    "lat": ["lat", "latitude"],
    "lon": ["lon", "longitude"],
    "temp": ["temp", "temperature", "t"],
    "energy": ["energy", "e", "keV", "MeV"],
    "time": ["time", "t", "jd", "mjd", "date"],
}

def normalize_colname(name: str) -> str:
    """Lowercase, strip units/parentheses and non-alnum, collapse spaces."""
    if not isinstance(name, str):
        return ""
    s = name.lower()
    # remove unit parentheses: "flux (erg/s)" -> "flux "
    s = re.sub(r"\(.*?\)", " ", s)
    # replace non-alphanumeric with space
    s = re.sub(r"[^a-z0-9]+", " ", s)
    s = " ".join(s.split())
    return s.strip()

def col_matches_alias(colname: str, alias_list: List[str]) -> bool:
    """Does normalized colname contain any alias token?"""
    n = normalize_colname(colname)
    for a in alias_list:
        if a in n.split() or a == n:
            return True
    return False

def map_columns(df) -> Dict[str, str]:
    """
    Map DataFrame columns to canonical roles.
    Returns a dict mapping role -> column_name (first match) e.g. {"wavelength":"wav", "flux":"f"}
    """
    cols = list(df.columns)
    mapping: Dict[str, str] = {}
    normcols = {c: normalize_colname(c) for c in cols}

    # Try to match primary roles first
    for role in ("wavelength", "flux", "lat", "lon", "time", "energy"):
        aliases = COLUMN_ALIASES.get(role, [])
        for c in cols:
            if c in mapping.values():
                continue
            if col_matches_alias(c, aliases):
                mapping[role] = c
                break

    # Fallback heuristics:
    # If no wavelength found but an 'x' like column exists, map that to wavelength
    if "wavelength" not in mapping:
        # find numeric-sounding columns with 'x' or 'index'
        for c in cols:
            nc = normcols[c]
            if "x" == nc or "index" in nc or "pixel" in nc or nc.isdigit():
                mapping["wavelength"] = c
                break

    # If no flux but a numeric column remains, pick the first numeric-like name not already used
    if "flux" not in mapping:
        for c in cols:
            if c in mapping.values():
                continue
            # pick columns with common tokens or that are numeric-sounding
            if any(tok in normcols[c] for tok in ["flux", "intensity", "count", "value", "y"]):
                mapping["flux"] = c
                break
    # final fallback: if both wavelength and flux missing, pick first two numeric columns
    if "wavelength" not in mapping or "flux" not in mapping:
        # attempt by dtype check if pandas available (caller should pass a pandas df)
        try:
            import numpy as np
            numeric_cols = [c for c in cols if np.issubdtype(df[c].dtype, np.number)]
            if len(numeric_cols) >= 2:
                if "wavelength" not in mapping:
                    mapping["wavelength"] = numeric_cols[0]
                if "flux" not in mapping:
                    mapping["flux"] = numeric_cols[1]
        except Exception:
            pass

    return mapping

def detect_data_type(mapping: Dict[str, str]) -> str:
    """
    Given a mapping returned by map_columns, return a type hint:
    - 'spectrum' if wavelength+flux present
    - 'map' if lat+lon+something present
    - 'table' otherwise
    """
    if "wavelength" in mapping and "flux" in mapping:
        return "spectrum"
    if "lat" in mapping and "lon" in mapping:
        return "map"
    return "table"